# 트랜잭션 격리 레벨에 대해 설명해 주세요

## 격리 레벨과 필요성

- 트랜잭션에서 일관성 없는 데이터를 허용하도록 하는 수준
- 트랜잭션이 독립적인 수행을 해야함 → Locking을 통해 다른 트랜잭션이 관여하지 못하도록 막아야함
    - 하지만 Locking으로 수많은 트랜잭션을 순서대로 처리하려한다면 성능은 낮을듯(Locking 범위를 줄여도)

### 격리 레벨의 종류

- Read Uncommitted (레벨 0)
    - 트랜잭션 처리중이거나, 아직 Commit 되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용
- Read Committed (레벨 1)
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기해야함
        - Commit이 이루어진 트랜잭션만 조회 가능 (대부분의 서버 Default설정)
- Repeatable Read (레벨 2)
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 불가능
        - MySQL에서 Default로 사용하는 Isolation Level
- Serializable (레벨 3)
    - 다른 사용자는 트랜잭션 영역에 해당되는 데이터에 대한 수정 및 입력 불가능

### 낮은 단계 Isolation Level을 활용할 때 발생하는 현상

- Dirty Read
    - 커밋되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽을 수 있도록하면 발생
    - 다른 트랜잭션에 의한 변경사항을 보게됨
    - Read Uncommitted
- Non-Repeatable Read
    - 한 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정 또는 삭제하면서 두 쿼리의 결과가 상이해짐 → 일관성이 깨짐
    - Read Committed, Read Uncommitted
- Phantom Read
    - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 이상 읽었을 때, 첫번째 쿼리에서 없던 레코드가 두번째 쿼리에서 나타나는 현상
    - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 나타남
    - Repeatable Read, Read Committed, Read Uncommitted

### MySQL(InnoDB-스토리지 엔진)에서 Undo 영역과 Redo 영역에 대해 설명해 주세요

- Undo 영역
    - 트랜잭션이 변경한 데이터를 원래 상태로 되돌리기 위한 정보를 저장
        - ROLLBACK이나 비정상 종료 대처
    - 일관된 읽기를 지원
        - 트랜잭션이 수행 중일 때 다른 트랜잭션에서 데이터를 읽을 경우 Undo 영역을 활용하여 변경 전 데이터를 제공
    - 트랜잭션 실패시 데이터 복구
- Redo 영역
    - 커밋된 변경 사항을 영구적으로 저장하기 위한 정보를 기록
    - 시스템 장애 발생 시 Redo 로그를 사용해 변경 사항을 재적용하여 지속성을 보장
