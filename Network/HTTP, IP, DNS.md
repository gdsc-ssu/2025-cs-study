> `성공과 실패를 결정하는 1% 의 네트워크 원리 - chap1. 웹 브라우저가 메시지를 만든다` 를 읽고 정리해보았습니다.

## HTTP
- HTTP 프로토콜: 클라이언트와 서버가 주고받는 메시지의 내용이나 순서를 정한 것
	- 클라이언트: 서버에게 리퀘스트 메시지를 보냄
	- 서버: 클라이언트에게 응답 메시지를 보냄
- 리퀘스트 메시지에는 무엇을, 어떻게 하겠다는 내용이 포함된다
	- 무엇을: URI로 엑세스 대상을 통칭하는 말  
	- 어떻게: 메서드(GET, POST)에 의해 웹 서버에 어떤 동작을 하고 싶은지를 전달
- 응답 메시지에는 실행 결과가 정상 종료되었는지 또는 이상이 발생했는지를 나타내는 스테이터스 코드가 포함된다

### HTTP 리퀘스트 과정
1. URL을 입력한다
	- URL에는 엑세스 대상의 프로토콜을 사용해 엑세스한다
	- 엑세스 대상에는 웹 서버(http:), 파일(ftp:), 메일(mailto:) 등이 있다
2. 브라우저는 URL을 해독한다

![image](https://github.com/user-attachments/assets/c7b3d0d4-7d30-4867-adb0-59723feb2373)

3. 리퀘스트 메시지를 만든다
	- 브라우저는 포맷에 맞게 리퀘스트 메시지를 만든다
	- 리퀘스트 메시지에 쓰는 URI는 한 개만 결정되어 있으므로 파일을 한번에 한 개씩만 읽을 수 있다
4. 응답이 돌아온다 
	- 응답의 경우 목적이 다른 스테이터스 코드와 응답 문구를 첫 번째 행에 써야 한다
	- 스테이터스 코드: 숫자로 작성하며 프로그램에 실행 결과를 알려주는 것이 목적
	- 응답 문구: 문장으로 작성하며 사람에게 실행 결과를 알리는 것이 목적

## IP
- **서브넷**이라는 작은 네트워크를 **라우터**로 접속하여 전체 네트워크가 만들어진다
1. IP 주소에 따라 액세스 대상이 어디에 있는지 판단하고 운반한다
2. 서브넷 안에 있는 허브가 운반하고 송신 측에서 가장 가까운 라우터까지 도착한다
3. 라우터가 메시지를 보낸 상대를 확인하여 다음 라우터를 판단하고 보내도록 지시한다
4. 다시 서브넷의 허브가 라우터까지 메시지를 보낸다
5. 1~4를 반복한다

![image](https://github.com/user-attachments/assets/e860bcd6-0f04-4002-829d-b7b2ee0782cc)

- IP 주소
	- 네트워크 주소(oo동) + 호스트 번호(oo번지)
	- 32비트의 디지털 데이터로 이것을 8비트씩 점으로 구분하여 10진수로 표기한다
- 넷마스크(서브넷 마스크)
	- IP 주소 만으로 어느 부분이 네트워크 번호인지 또는 호스트 번호인지 알 수 없다
	- 정보를 필요에 따라 IP 주소에 **넷마스크(서브넷 마스크)** 추가한다
- 넷마스크가 1인 부분은 네트워크 번호를 나타내고 넷마스크가 0인 부분은 호스트 번호를 나타낸다

![image](https://github.com/user-attachments/assets/8fc71ef9-cc53-4ae9-afca-d0ce8a4c1c5b)

- IP 주소의 호스트 번호
	- 모두 0: 서브넷 자체(0)
	- 모두 1: 브로드캐스트(255)

#### 도메인명과 IP주소를 구분하여 사용하는 이유  
- 숫자로 나열한 IP주소는 기억하기 어렵다
- IP주소는 4 바이트만 차지하지만 도메인 명은 최대 255 바이트까지 차지하여 라우터가 부하된다. 데이터를 운반하는 동작에 더 많은 시간이 걸리면서 네트워크 속도가 느려진다

## DNS
- 이름을 알면 IP주소를 알 수 있다거나 IP주소를 알면 이름을 알 수 있다
-  DNS 리졸버(= 리졸버): DNS 원리를 사용하여 IP주소를 조사한다 (네임 리졸루션)
- 리졸버는 Socket 라이브러리에 들어있다

##### 리졸버 내부의 동작
1.  '`www.naver.com` 이라는 서버의 IP 주소를 알려주세요' 라는 메시지를 만든다
2. OS 내부의 프로토콜 스택을 의뢰하여 DNS 서버에 요청을 보낸다
	- 참고) 리졸버는 브라우저와 같이 네트워크에 대해 데이터를 송수신하는 기능이 없음
3. DNS 서버에서 돌아온 응답 메시지를 해독하고 IP 주소를 추출한다
4. 메모리 영역에 IP 주소를 저장한다
5. 애플리케이션에 IP 주소를 전달한다

![image](https://github.com/user-attachments/assets/089911c2-ace5-49e9-807c-5243a171784a)

### DNS 서버의 기본 동작
- DNS 서버에 등록된 정보등록된 정보
	1. 이름: 목적지
	2. 클래스: 인터넷 이외에도 네트워크에서 이용까지 검토하여 이것을 식별하기 위해 클래스라는 정보를 준비했지만, 지금은 인터넷 이외의 네트워크가 소멸되었으므로 항상 인터넷을 나타내는 'IN' 값이 된다
	3. 타입: 어떤 정보가 지원되는지를 나타낸다. 예를 들어 A이면 이름에 IP주소가 지원되는 것을 나타내며 MX이면 이름에 메일 배송 목적지가 지원된다는 것을 나타낸다. 이 타입에 따라 회답하는 정보의 내용이 달라진다
	4. 소스 레코드: 반환할 IP 주소
- DNS 서버는 이름, 클래스, 타입이 일치하는 것을 찾아 주소(소스 레코드)를 회답한다

![image](https://github.com/user-attachments/assets/b0a26366-406f-493e-b089-e5ab5ca4765b)

#### 도메인 계층
- 인터넷에는 막대한 수의 서버가 있는데 이것을 1대의 DNS 서버에 등록하는 것은 불가능하다
- 정보를 분산시켜서 다수의 DNS 서버에 등록하고 다수의 DNS 서버가 연대한다
- **도메인명**이라는 계층적 구조를 가진다
	- `www.naver.com` -> com, naver, www
	- naver 에 해당하는 것을 도메인 이라고 한다
	- 도메인마다 서브 도메인을 만들어 여러 도메인을 할당 할 수 있다

#### 도메인 서버에 등록한 IP 조회
- 어느 DNS 서버에 등록되어 있는지
- 하위의 DNS 서버를 상위의 DNS 서버에 등록하여 루트 도메인에서 차례로 아래 쪽으로 거슬러 내려갈 수 있다

![image](https://github.com/user-attachments/assets/c3367b56-3518-43ea-bd94-99c4edcb268d)

- 가장 가까운 DNS 서버 -> 루트 도메인 -> Top-Level 도메인 -> Second-Level 도메인

![image](https://github.com/user-attachments/assets/bd186d74-2182-4cb0-ba90-a025be171f7a)

#### DNS 서버 캐싱
- DNS 서버는 한 번 조사한 이름을 캐시에 기록할 수 있다 -> 성능 향상