# DFS & BFS
### DFS(깊이 우선 탐색, Depth-First Search)

- 깊은 부분을 우선적으로 탐색하는 알고리즘으로 시작 노드(root)를 먼저 방문한 뒤, 그 노드의 모든 자식 노드를 차례로 방문
- 스택 또는 재귀 함수를 이용
- 동작 과정
    1. 시작 노드를 스택에 삽입 후 방문 처리
    2. 스택의 최상단 노드에 방문하지 않은 인접 노드가 있다면 그 노드를 스택에 넣고 방문 처리. 만약 방문하지 않은 인접 노드가 없다면 스택에서 최상단 노드를 꺼냄
    3. 2번 과정을 더 이상 수행할 수 없을때 까지 반복
- 구현
    - 재귀 이용
    
    ```cpp
    int n,m,v;
    int visited[1001]; // 방문여부 체크
    int mat[1001][1001]; // 인접행렬
    queue<int> q;
    stack<int> st;
    
    /*재귀를 이용한 dfs 구현*/
    void dfs(int v){ 
        cout<<v<<" ";
        visited[v] = 1; 
        for(int i = 1; i<=n; i++){
            if(visited[i] == 0 && mat[v][i] == 1){ 
                dfs(i);
            }
        }
    }
    ```
    
    - 스택 이용
    
    ```cpp
    int n,m,v;
    int visited[1001]; // 방문여부 체크
    int mat[1001][1001]; // 인접행렬
    queue<int> q;
    stack<int> st;
    
    /*스택을 이용한 dfs 구현*/
    void dfs(int v){
        st.push(v);
        while(!st.empty()){
            v = st.top();
            st.pop();
            if(visited[v] == 0){
                cout<<v<<" ";
            }
            visited[v] = 1;
            for(int i =n; i>0; i--){
                if(visited[i] == 0 && mat[v][i] == 1){
                    st.push(i);
                }
            }
    
        }
    }
    ```
    
- DFS와 백트레킹
    - 백트레킹(Back Tracking)은 해를 찾는 도중 해가 될 수 없는 상태가 되면, 다시 이전으로 되돌아가 해를 찾아가는 방법으로 최적화 문제와 결정 문제를 풀 때 사용된다.
    - 백트레킹을 위한 개념
        - 상태공간트리 : 문제 해결 과정의 중간 상태들을 모두 각각 하나의 node로 구현해놓은 트리
        - 유망하다(promising) : 어떤 노드를 방문했을 때, 해당 경로에 해가 있다고 판단되는 경우 유망하다고 표현한다. 반대로 전혀 해답이 나올 가능성이 없는 노드는 유망하지 않은 것이다.
        - 가지치기(pruning) : 더 이상 탐색할 필요가 없는 노드를 탐색하지 않고 제외시키는 것을 말한다.
    - 백트레킹 절차
        1. 상태공간트리의 깊이우선탐색(DFS)를 실시한다.
        2. 각 노드가 유망한지 점검한다.
            
            3-1. 만약 그 노드가 유망하지 않다면, 가지쳐서(prunning) 더이상 탐색하지않고 그 노드의 부모노드로 돌아가서 다음 자식노드를 탐색한다.
            
            3-2. 만약 그 노드가 유망하다면, 그 노드의 자식노드를 탐색한다.
            
    - **백트레킹과 DFS**
        
        백트레킹에서는 모든 후보를 탐색하는 DFS가 쓰인다. 다만 실제로 모든 후보를 탐색하지 않고, 가지치기를 하기에 유망성을 판단하여 특정 노드만 탐색한다. 따라서 가지치기를 얼마나 잘하는지가 백트레킹의 효율성을 결정한다.
        

### BFS(너비 우선 탐색, Breadth-First Search)

- 가까운 노드부터 우선적으로 탐색하는 알고리즘
- 큐 이용
- 동작 과정
    1. 시작 노드를 큐에 삽입하고 방문 처리
    2. 큐에서 노드를 꺼낸 후, 해당 노드의 인접 노드 중 방문하지 않은 노드를 모두 큐에 삽입하고 방문 처리
    3. 2번 과정을 더 이상 수행할 수 없을때 까지 반복
- 구현
    
    ```cpp
    int n,m,v;
    int visited[1001]; // 방문여부 체크
    int mat[1001][1001]; // 인접행렬
    queue<int> q;
    stack<int> st;
    
    void bfs(int v){
        q.push(v);
        visited[v] = 1;
        while(!q.empty()){
            v = q.front();
            q.pop();
            cout<<v<<" ";
            for(int i=1; i<=n; i++){
                if(visited[i] == 0 && mat[v][i] == 1){
                    q.push(i);
                    visited[i] = 1;
                }
            }
        }
    }
    ```
    

### DFS vs BFS

두 방식 모두 조건 내의 모든 노드를 검색한다는 점에서 시간 복잡도는 동일

| DFS | BFS |
| --- | --- |
| 시작 노드에서 한 경로를 따라 최대한 깊게 탐색 후, 다른 경로 탐색 | 시작 노드에 인접한 노드 모두 탐색 후, 다음 노드로 이동 |
| 스택 또는 재귀 함수 이용 | 큐 이용 |
| 그래프 구조 파악에 유용 | 최단 경로를 찾거나, 노드 간 최단 거리 등을 구할 때 유용 |