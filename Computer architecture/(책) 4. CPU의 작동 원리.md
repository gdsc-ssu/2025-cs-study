# CPU의 작동 원리

## 1. ALU와 제어장치

### ALU

ALU는 CPU 내부에서 계산을 담당한다

- 레지스터를 통해 피연산자를 받아들이고,
제어장치로부터 수행할 연산을 알려주는 제어 신호를 받아들인다
- 연산한 결과값과 플래그를 내보낸다

플래그 → 연산 결과에 대한 추가적인 상태 정보

- 부호 플래그 / 제로 플래그 / 캐리 플래그 / 오버플로우 플래그 / 인터럽트 플래그 / 슈퍼바이저 플래그
→ 플래그 레지스터에 저장됨

### 제어장치

제어장치는 제어 신호를 내보내고, 명령어를 해석하는 부품이다

- 제어장치는 클럭, 현재 수행할 명령어, 플래그, 제어 신호를 받아들인다
    1. 클럭 신호를 받아들인다
    클럭(clock) → 컴퓨터의 부품을 움직일 수 있게 하는 시간 단위
    2. ‘해석해야 하는 명령어’를 받아들인다
    CPU가 해석해야 할 명령어는 명령어 레지스터에 저장된다
    명령어를 받아들이고 해석한 후, 제어 신호를 발생시켜 컴퓨터 부품이 수행해야 할 내용을 알려준다
    3. 플래그 레지스터 속 플래그 값을 받아들인다
    플래그 → ALU 연산에 대한 추가적인 상태 정보
    4. 시스템 버스, 그중에서 제어 버스로 전달된 제어 신호를 받아들인다
    제어 버스를 통해 외부로부터 전달된 제어 신호를 받아들인다
- 제어장치는 CPU 내부와 외부로 제어 신호를 내보낸다
    
    제어장치가 메몰, 입출력장치에 새로운 값을 쓰거나 읽고 싶을 때
    ALU에서 수행할 연산을 지시하기 위해서, 레지스터에서 데이터 이동 및 명령어 해석을 위해서

## 2. 레지스터

### 알아야할 레지스터의 종류

- 프로그램 카운터(PC: Program Counter)
→ 메모리에서 읽어들일 명령어의 주소를 저장
- 명령어 레지스터(IR: Instruction Register)
→ 해석할 명령어, 즉 방금 메모리에서 읽어 들인 명령어를 저장
제어장치는 명령어 레지스터 속 명령어를 받아들이고 이를 해석하여 제어 신호를 내보냄
- 메모리 주소 레지스터(MAR: Memory Buffer Register)
→ 메모리의 주소를 저장
- 메모리 버퍼 레지스터(MBR: Memory Buffer Register)
→ 메모리와 주고받을 값(데이터와 명령어)을 저장
- 플래그 레지스터(flag register)
→ 연산 결과 또는 CPU 상태에 대한 부가적인 정보를 저장
- 범용 레지스터(general purpose register)
→ 일반적인 상황에서 자유롭게 사용할 수 있는 레지스터
데이터와 주소 모두를 저장할 수 있음
- 스택 포인터
- 베이스 레지스터

### 메모리에 저장된 프로그램을 실행하는 과정

1. CPU로 실행할 프로그램의 1000번지에는 1101(2)가 저장되어 있다
2. 프로그램을 처음부터 실행하기 위해 프로그램 카운터에 1000이 저장된다
3. 1000번지를 읽어 들이기 위해서 주소 버스로 1000번지를 내보낸다
이를 위해 메모리 주소 레지스터에는 1000이 저장된다
4. 메모리를 읽는 제어 신호는 제어 버스를 통해 메모리로 보내진다
메모리 주소 레지스터 값이 주소 버스를 통해 메모리로 보내진다
5. 메모리 1000번지에 저장된 값은 데이터 버스를 통해 메모리 버퍼 레지스터에 전달된다
프로그램 카운터는 1000에서 1001로 증가되어 다음 명령어를 읽어 들일 준비를 한다
6. 메모리 버퍼 레지스터에 저장된 값(데이터와 명령어)은 명령어 레지스터로 이동한다
7. 제어장치는 명령어 레지스터의 명령어를 해석하고 제어 신호를 발생시킨다
8. 프로그램 카운터의 값이 증가했으니 1000번지 명령어 처리가 끝나면 CPU는 다음 명령어(1001번지)를 읽어 들인다

프로그램 카운터가 꾸준히 증가하기 때문에 CPU가 메모리 속 프로그램을 순차적으로 읽고 실행할 수 있다
but 순차적인 실행 흐름이 끊기는 이유:
JUMP, CALL과 같은 특정 메모리 주소로 실행 흐름이 이동하는 명령어가 있을 경우, 인터럽트가 발생할 경우

### 특정 레지스터를 이용한 주소 지정 방식

- 스택 주소 지정 방식
    
    스택 포인터(stack pointer)
    → 스택에 마지막으로 저장한 값의 위치를 저장하는 레지스터
    
- 변위 주소 지정 방식(displacement addressing mode)
→ 오퍼랜드 필드의 값(변위)과 특정 레지스터의 값을 더하여 유효 주소를 얻어내는 방식
    - 상대 주소 지정 방식(relative addressing mode)
    → 오퍼랜드와 프로그램 카운터의 값을 더하여 유효 주소를 얻는 방식
    프로그램 카운터가 실행하려는 명령어에서 오퍼랜드에 해당하는 주소만큼 이동하여 명령어를 실행
    분기하는 특저 주소의 코드를 실행할 때 사용된다
    - 베이스 레지스터 주소 지정 방식(base-register addressing mode)
    → 오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식
    베이스 레지스터 속 기준 주소로부터 얼마나 떨어져 있는 주소에 접근할 것인지 연산하여 유효 주소를 얻어내는 방식

### 정리

1. 프로그램 카운터는 메모리에서 가져올 명령어의 주소, 명령어 레지스터는 해석할 명령어를 저장한다
2. 메모리 주소 레지스터는 메모리의 주소, 메모리 버퍼 레지스터는 메모리와 주고받을 데이터를 저장한다
3. 범용 레지스터는 데이터와 주소를 모두 저장, 플래그 레지스터는 연산 결과 혹은 CPU 상태에 대한 부가 정보를 저장한다
4. 스택 포인터는 스택 최상단의 위치를 저장한다
5. 베이스 레지스터에 저장된 주소는 기준 주소로서의 역할을 한다

## 3. 명령어 사이클과 인터럽트

### 명령어 사이클

명령어 사이클(Instruction cycle)
→ 하나의 명령어가 처리되는 주기

- 인출 사이클(fetch cycle)
→ 메모리에 있는 명령어를 CPU로 가지고 오는 단계
- 실행 사이클(execution cycle)
→ CPU로 가져온 명령어를 실행하는 단계
- 간접 사이클(indirect cycle)
→ 명령어를 실행하기 위해 메모리 접근이 한 번 더 필요할 때 간접 사이클을 거친다
    - 어떤 명령어는 인출과 실행 사이클만으로도 실행되지만,
    메모리 접근이더 필요한 경우에 인출, 간접, 실행 사이클을 거쳐 실행된다
- 인터럽트 사이클

### 인터럽트

인터럽트(interrupt)
→ CPU의 정상적인 작업을 방해하는 신호

- 동기 인터럽트(synchronous interrupt)
→ CPU가 예외적인 상황에 마주쳤을 때 발생하는 인터럽트 == 예외(execption)
    - 예외의 종류
        - 폴트(fault) → 예외를 처리한 직후 예외가 발생한 명령어부터 실행을 재개하는 예외
        - 트랩(trap) → 예외를 처리한 직후 예외가 발생한 명령어 다음 명령어부터 실행을 재개하는 예외
        - 중단(abort) → CPU가 실행 중인 프로그램을 강제로 중단시킬 수밖에 없는 심각한 오류를 발견했을 때 발생하는 예외
        - 소프트웨어 인터럽트(software interrupt) → 시스템 호출이 발생했을 때 나타나는 예외
- 비동기 인터럽트(asynchronous interrupts)
→ 주로 입출력장치에 위해 발생하는 인터럽트 == 하드웨어 인터럽트(알림과 같은 인터럽트)
    
    하드웨어 인터럽트는 입출력 작업 중에서도 CPU로 하여금 효율적인 명령어를 처리할 수 있게 한다
    

### 하드웨어 인터럽트 처리 순서

1. 입출력장치는 CPU에 인터럽트 요청 신호를 보낸다
2. CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다
3. CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다
4. 인터럽트를 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다
5. CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다
6. 인터럽트 서비스 루틴 실행이 끝나면 백업한 작업을 복구하여 실행을 재개한다
- 인터럽트 요청 신호
→ CPU의 작업을 방해하는 인터럽트에 대한 요청
- 인터럽트 플래그(interrupt flag)
→ 인터럽트 요청 신호를 받아들일지 무시할지를 결정하는 비트
    
    하드웨어 인터럽트에는 인터럽트 플래그로 막을 수 있는 인터럽트(maskable interrupt)와
    막을 수 없는 인터럽트(non maskable interrupt)가 있다
    
- 인터럽트 벡터
→ 인터럽트 서비스 루틴의 시작 주소를 포함하는 인터럽트 서비스 루틴의 식별 정보
    
    CPU는 인터럽트 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다
    
- 인터럽트 서비스 루틴
→ 인터럽트를 처리하는 프로그램
    
    CPU가 인터럽트를 처리한다 == 인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아온다
    
    CPU는 인터럽스 서비스 루틴을 실행하기 전에 프로그램 카운터 값 등 현재 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업한다
    
    인터럽트 서비스 루틴의 시작 주소가 위치한 곳으로 프로그램 카운터의 값을 갱신하고, 인터럽트 서비스 루틴을 수행한다
    

### 정리

1. 명령어 사이클은 하나의 명령어가 처리되는 주기로, 인출, 실행, 간접, 인터럽트 사이클로 구성된다
2. 인터럽트는 CPU의 정상적인 작업을 방해하는 신호이다
3. 인터럽트의 종류에는 예외와 하드웨어 인터럽트가 있다
4. 인터럽트 서비스 루틴은 인터럽트를 처리하기 위한 동작들로 이루어진 프로그램이다