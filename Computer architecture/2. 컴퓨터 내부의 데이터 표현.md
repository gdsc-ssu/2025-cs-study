@ -1,128 +0,0 @@
# 2.3 진법의 의미

- 진법 -> 유한한 개수의 심볼로 모든 것을 표현할 수 있다
    -> 0이 반드시 필요하다

- 10진법
'자릿수'와 '나머지'의 개념이 무척이나 중요하다
ex) 432(10) = (4x100+3x10+2X1)
2는 10으로 나눈 나머지, 3은 100으로 나눈 나머지 라고 생각하는 것이 좋다

- 2진법 -> 8진법, 16진법으로의 변환
8진법, 8개의 인자를 가짐(0~7)
16진법, 16개의 인자를 가짐(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)
2진수 3비트 -> 8진수 1자리 -> LSB부터 3자리씩 묶는다
2진수 4비트 -> 16진수 1자리 -> LSB부터 4자리씩 묶는다

- 정보 표현의 단위

비트(bit): Binary Digit, 0과 1로만 구성된다
컴퓨터 내부에서 정보 저장(표현)의 기본 단위

바이트(byte): 8비트 -> 2의 8승, 256개의 정보 표현 가능
            K(killo) -> 10의 세제곱 근사치인 1024를 사용

            비트의 개수 != 표현할 수 있는 범위
            비트의 개수는 물리적인 저장공간의 크기를 말한다
            8KB = 8*1024 Byte
            표현할 수 있는 범위는 그 수의 비트를 사용하여서 얼마나 많은 다른 값들을 표현할 수 있는지를 말한다
            8KB = 2의 16승 bit -> 2의 65536승 가지수로 표현 가능

워드(word): 여러 바이트를 묶은 시스템 처리 단위이다


# 2.4 진법변환(base conversion)

- 정수 부분의 변환

정수 10진수 -> 2진수로 변환 시 나머지 개념을 이용
ex) 41(10) = 101101(2)
41을 계속 2로 나누면서 가장 큰 값으로 나눈 나머지부터 가장 작은 값으로 나눈 나머지의 방향으로 적어준다

- 소수 부분의 변환

10진수 -> 2진수
소수파트는 곱해서 정수 파트로 올려버린다고 생각하자
정수를 제외한 소수부분에 계속적으로 2를 곱하면서 정수로 자리 올림이 발생하는지 보자

10진수 -> n진수
소수부분에 값 n을 지속적으로 곱해가면 된다

ex) 유한소수 0.2(10) -> 무한순환소수 0.0011(2)
컴퓨터에서는 실수를 정확히 표현할 수 없고, 대부분의 실수는 근사값이다


# 2.5 정수의 표현

컴퓨터에서 숫자 표현 -> 정수(integer numbers)
                -> 실수(real numbers)
정수 2 != 실수 2.0 완전히 다른 2진수 형태로 표시된다
또한 변수(variabes)를 사용하면 변수는 물리적으로 주기억장치(main memory)에 위치하여 3이라는 값을 가지게 된다. 기억장치는 렘의 주소를 추상화 시켜놓은 것이다

정수 -> 부호 없는 정수(unsigned integer): 0, 양의 정수
    -> 부호 있는 정수(signed integer): 0, 양의 정수, 음의 정수

## 부호 없는 정수(unsigned integer): 0, 양의 정수
표현가능 범위: 
0 ~ +(2의 n승 -1) (n비트)
0 ~ +255 (8비트)

- 오버플로우(Overflow)
8비트는 255까지만 표현가능하다
그 다음 자릿수로 넘어가는 오버플로우 발생 시 연산이 틀린다
그렇다고 오버플로우가 나도 프로그램이 멈추진 않는다
컴퓨터는 오버플로우를 발생을 알 수 있음에도,
프로그램 실행 중에 오버플로우 검사를 하면 속도가 느려지므로 오버플로우에 대한 대비를 하지 않는다

255에 1을 더하면 0이 되는 것이다
원처럼 시계 방향으로 돌아서 254 -> 255 -> 0 -> 1 순서가 된다

## 부호 있는 정수(signed integer)
-> 부호와 절댓값 표현(sign and magnitude representation)
-> 보수표현(complement representation)

### 부호와 절댓값(sign and magnitude)
MSB가 0이면 양수, 1이면 음수
ex) +5: 0000 0101(2)
    -5: 1000 0101(2)

표현가능 범위:
-(2의 n-1승 -1) ~ +(2의 n-1승 -1) (n비트)
-127 ~ +127 (8비트)

    - 치명적인 문제점 2개
    1) 0이 2개(+0, -0)
    2) 덧셈이 복잡해진다 -> 속도가 느려짐

### 2의 보수(two's complement)
- 보수란?
절댓값이 같고 부호가 다른 두 수
덧셈의 결과가 0이다

ex) +10(10)의 보수
= 00001010(2)의 보수
= NOT 00001010(2) + 1
= 11110101(2)+ 1
= 11110110(2)
= -10(10)
NOT 연산을 통해 비트반전읠 준다(뺄셈 연산)
그 다음에 +1을 한다
처음에 NOT 연산을 통해 더 큰 수에서 자리 내림을 하기 위해서 1을 뺀 것이기 때문에 나중에 1을 더해준다

- 보수 표현 -> 부호와 절댓값의 문제 해결
1) 부호 없이 음수를 표현할 수 있다
    부호는 없지만, MSB가 0이면 양수이고, MSB가 1이면 음수이다
    부호와 절댓값 표현은 0이 +0, -0으로 두 개 였지만
    2의 보수표현은 0이 한 개라서 으무가 -128까지 한 개 더 존재할 수 있다
2) 덧셈기가 간단해진다

표현가능 범위:
-(2의 n-1승) ~ +(2의 n-1승 -1) (n비트)
-128 ~ +127 (8비트)

- 2의 보수 오버플로우 발생
-1 -> 0 으로 오버플로우 발생
+127 -> -128 으로 오버플로우 발생


# 2.6 실수의 표현

- 컴퓨터 내부에서 곱셈은 덧셈을 반복적으로 하는 것 아닌가?
실수의 덧셈 != 실수의 곱셈
오차가 누적되는 횟수가 다르기 때문이다
ex) 1/3 x 3만 = 1만
    1/3 + 1/3 + ... + 1/3 = 1만
    이지만 곱셈보다 덧셈의 오차누적 횟수가 많기 때문에 값이 같지 않다

- 실수의 자료형
float 4바이트
double 8바이트 -> float 보다 더 정확한 표현이 가능하다
메모리와 속도 때문에 실수를 둘로 구분한다
float a != float b

## 고정 소수점 표현 방법(fixed-point representation)
소수점의 위치를 고정시켜 표현하는 방법, 부호 비트도 존재한다
장점: 연산 속도가 빠르다
단점: 큰 숫자를 표현하기 어렵다

## 부동 소수점 표현 방법(floating-point representation)
부동이란 떠다니는 소수점이라는 뜻이다, float가 여기서 나오게 된다

부동 소수점을 만들기 위해서는 10진수 -> 2진수 -> 정규형으로 만드는 과정을 거쳐야 한다
정규형을 사용하는 이유:
정수표현을 한 자리만 남김으로써 실수 표현을 통일하기 위해서이다
ex) 0.34(10)
-> 0.010101110...(2)
-> 1.0101110... x 2의 -2승(2)

부동 소수점 표현에는 자리마다 역할이 있다(8비트 기준)
가수의 부호(Sign) / 지수(Exponent) / 가수(Significand) 가 각 각 1 / 3 / 4 자리 있다

부동소수점에서는 2의 보수처럼 NOT으로 반전을 주는 방식을 사용해서는 안된다
2의 보수는 정수표현일 때만 사용하는 것이다
부동  소수점 표현 방법은 실수를 표현하는 방식임을 잊지 말자

### 초과표현(excess representation)
사용 이유: 지수를 위해서 초과표현을 사용한다
지수에 2의 보수를 사용하면 대소비교를 한 눈에 확인하기 어렵다
초과표현을 사용하면 지수를 위해 사용되는 비트가 양수범위가 되기 때문에 대소비교를 확인하기 좋다

ex) 어느 숫자가 더 클까?
1) 1.000 x 2의 0승
2) 1.111 x 2의 -1승
정규형에서는 지수가 큰 수가 큰 수이다
정규형으로 만들었기 때문에 실수 부분의 크기보다 지수의 크기가 더 영향을 미치기 때문이다

1) 1.000 x 2의 0승
00111000
2) 1.111 x 2의 -1승
00101111
로 표현할 수 있다

- 지수를 가수보다 앞에 위치시키는 것의 장점:
지수를 위해서 초과표현을 사용하기 때문에
실수의 대소비교임에도 정수처럼 MSB부터 비교해도 된다
(정수의 연산이 실수의 연산보다 빠르기에 이것이 장점이다)

- 비트 별 초과표현
지수표현에 3비트 사용 -> 3 초과표현
지수표현에 4비트 사용 -> 7 초과표현
3비트를 사용하면 지수 -7에서 0까지 사용 가능
음수와 양수의 비율을 균등하게 하기 위해서 3초과 표현을 사용

### hidden bit
정규형을 사용하게 되면서 정수 부분이 무조건 1로 고정되었다
1을 숨기고 가수 1비트를 더 표현하기 위해서 hidden bit를 사용한다
-> 조금 더 정확한 실수 표현이 가능해진다

- special values
0000 0000(2)로 hidden bit를 사용하면
1.0000 x 2의 -3승 = 0.125(10)
0000 00000(2) != 0(10)

그럼 0(10)은 어떻게 표현하지?
0000 0000(2) = 0(10)이라고 약속
0000 0001(2) = +0.1328125(10)
-0.1328125(10)에서 +0.1328125(10) 사이는 표현불가, 언더플로우 발생
-31.0(10)미만, -31.0(10) 초과는 오버플로우 발생

- IEEE 754 Floating Standard
실수 표현하는 국제 표준이다
1) Single precision(단정밀도)
지수를 표현하는 부분이 상대적으로 많으므로 숫자의 표현 범위가 넓다
2) Double precision(배정밀도)
가수를 표현하는 부분이 상대적으로 많으므로 숫자의 정밀도가 높다


# 2.7 문자의 표현

- ASCII 코드
처음에는 7비트였으나, 현재는 8비트로 사용된다
-> 256개의 문자 표현이 가능하다
BCD(Binary Coded Decimal)
-> 0에서 9까지 1자릿수를 4비트의 2진수로 표현

- 유니코드(UNICODE): UTF-16 Encoding
2의 16개의 문자표현 가능
유니코드 앞 256개는 ACSII코드랑 일치
한글, 가장 많이 사용하는 방법이 UTF-8이다