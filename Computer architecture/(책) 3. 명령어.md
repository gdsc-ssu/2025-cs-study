# 명령어

## 1. 소스 코드와 명령어

고급 언어는 사람이 이해하고 작성하기 쉽게 만들어진 언어이다
저급 언어는 컴퓨터가 직접 이해하고 실행할 수 있는 언어이다

- 저급 언어

    1. 기계어 → 0과 1로 이루어진 명령어
    2. 어셈블리어 → 기계어를 사람이 읽기 편한 형태로 번역

- 고급언어가 저급언어로 변환되는 방법

    1. 컴파일 방식 → 통번역 → 오류 있으면 컴파일 불가
    2. 인터프리터 방식 → 실시간 통역 → N번째 오류, N-1번째까지 코드 수행됨

(여러 개의)목적 코드 → 링킹 → 하나의 실행 파일
모든 소스 코드는 컴퓨터 내부에서 명령어로 변환된다
고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급언어(명령어)로 변환 되어야함

## 2. 명령어의 구조

**명령어 = 연산코드 + 오퍼랜드**

**연산코드와 오퍼랜드**

- 연산 코드(operation code) -> 명령어가 수행할 연산
    오퍼랜드 필드에는 대부분 메모리나 레지스터의 이름이 담긴다
    -> 주소 필드라 부르기도 함

연산 코드의 종류
1. 데이터 전송
    LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
    PUSH: 스택에 데티터를 저장하라
    POP: 스택의 최상단 데이터를 가져와라
2. 산술/논리 연산
3. 제어 흐름 변경
4. 입출력 제어

- 오퍼랜드(operand) -> 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치를 명시
    1. 오퍼랜드가 없는 경우 -> 0 주소 명령어
    2. 오퍼랜드 1개 -> 1주소 명령어
    3. 오퍼랜드 2개, 3개, 여러 개 -> 3주소 명령어

**주소 지정 방식**

왜 오퍼랜드 필드에 메모리나 레지스터의 주소를 담는 것일까?
그냥 연산코드에 사용할 데이터를 넣어도 되는거 아닌가?
-> 명령어의 길이 때문!!

주소가 담긴다면 표현할 수 있는 데이터의 크기
-> 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다

- 유효 주소(effectice address) -> 연산의 대상이 되는 데이터가 저장된 위치
- 주소 지정 방식(adressing mode)
-> 오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용된 데이터 위치를 찾는 방법
-> 유효 주소를 찾는 방법
    1. 즉시 주소 지정 방식(immediate addressing mode)
    오퍼랜드 필드에 명시 -> 연산에 사용할 데이터
    2. 직접 주소 지정 방식(direct addressing mode)
    유효 주소(메모리 주소)
    -> 유효 주소 표현 가능 범위: 연산 코드의 비트 수만큼 줄어든다
    3. 간접 주소 지정 방식(indirect addressing mode)
    유효 주소의 주소
    -> 유효 주소 표현 가능 범위: 메모리 전체 2의 16승 만큼 표현 가능하다
    4. 레지스터 주소 지정 방식(register addressing mode)
    유효 주소(레지스터 이름)
    -> 직접 주소 지정 방식과 비슷한 문제를 공유
    5. 레지스터 간접 주소 지정 방식(register indirect addressing mode)
    유효 주소를 저장한 레지스터

**스택과 큐**

- 스택(stack)
후입선출(LIFO) / PUSH, POP

- 큐(queue)
선입선출(FIFO)