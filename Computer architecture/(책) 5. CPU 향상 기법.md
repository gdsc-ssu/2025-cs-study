# 컴퓨터구조 5장 : CPU 성능 향상 기법


## 1. 빠른 CPU를 위한 설계 기법

### 클럭

컴퓨터 부품들은 ‘클럭 신호’에 맞춰 움직인다

클럭 속도가 높아지면 CPU는 명령어 사이클을 더 빠르게 반복할 것이고, 다른 부품들도 그에 발맞춰 더 빠르게 작동할 것이다

### 코어와 멀티 코어

클럭 속도를 높이는 방법 외의 CPU의 성능을 높이는 방법
→ CPU의 코어와 스레드 수를 늘리는 방법

- 코어(core) → 명령어를 실행하는 부품
- 멀티코어(multi-core) = 멀티코어 프로세서 → 코어를 여러 개 포함하고 있는 CPU

코어마다 처리할 명령어들을 얼마나 적절하게 분배하느냐가 중요함

### 스레드와 멀티스레드

스레드(thread) → 실행 흐름의단위

- 하드웨어적 스레드
→ 하나의 코어가 동시에 처리하는 명령어 단위
    
    여러 스레드를 지원하는 CPU는 하나의 코어로도 여러 개의 명령어를 동시에 실행할 수 있다
    ex) 2코어 4스레드 → 한 번에 네 개의 명령어를 처리할 수 있는 CPU
    
    - 멀티스레드(multithread) 프로세서 = 멀티스레드 CPU
    → 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
    → 여러 개의 하드웨어적 스레드를 지원하는 CPU
    

- 소프트웨어적 스레드
→ 하나의 프로그램에서 독립적으로 실행되는 단위
    
    프로그램의 여러 부분이 동시에 실행될 수도 있다

## 멀티스레드 프로세서

레지스터가 핵심이다
2코어 4스레드 CPU는 한 번에 네 개의 명렁어를 처리할 수 있다
→ 프로그램 입장에서 봤을 때 작업 흐름이 4개 있는 것처럼 보인다
→ 논리 프로세서가 4개

## 정리

- 코어 → 명령어를 실행할 수 있는 ‘하드웨어 부품’
- 스레드 → ‘명령어를 실행하는 단위’
- 멀티코어 프로세서 → 명령어를 실행할 수 있는 하드웨어 부품이 CPU 안에 두 개 이상 있는 CPU를 의미
- 멀티스레드 프로세서 → 하나의 코어로 여러 개의 명령어를 동시에 실행할 수 있는 CPU를 의미


## 2. 명령어 병렬  처리 기법

명령어 병렬 처리 기법(ILP; Instruction-Level Parallelism)
→ 명령어를 동시에 처리하여 CPU를 한시도 쉬지 않고 작동시키는 기법

- 명령어 파이프 라이닝
- 슈퍼스칼라
- 비순차적 명령어 처리

### 명령어 파이프라인

명령어 파이프라이닝(Instruction pipelining)

1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

같은 단계가 겹치지만 않는다면 CPU는 ‘각 단계를 동시에 실행할 수 있다’

파이프라인 위험(pipeline hazard)

- 데이터 위험(data hazard)
→ 데이터 의존적인 두 명령어를 무작정 동시에 실행하려고 하면 파이프라인이 제대로 작동하지 않는 것
- 제어 위험(control hazrad)
→ 실행 흐름이 바뀌어 PC 값에 갑작스러운 변화가 생기면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모 없어지게 되는 것
이를 위해 분기 예측(branch prediction)을 사용
- 구조적 위험(structural hazard)
→ 명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 같은 CPU 부품을 사용하려고 할 때 발생

### 슈퍼스칼라

슈퍼스칼라(superscalar)
→ CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조

파이프라인 위험에 더욱 더 조심해야함

### 비순차적 명령어 처리

비순차적 명령어 처리(OoOE; Out-of-order execution)
→ 명령어의 ‘합법적인 새치기’
→ 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인을 멈추는 것을 방지하는 기법

## 3. CISC와 RISC

### 명령어 집합

명령어 집합(instruction set) or 명령어 집합 구조(ISA; Instruction Set Architecture)

CPU 마다 ISA가 다를 수 있다

ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다

ISA는 CPU 언어임과 동시에 CPU를 비롯한 하드웨어가 소프트웨어를 어떻게 이해할지에 대한 약속이라고 볼 수 있다

- ISA
    - CISC
    - RISC

### CISC

CISC(Complex Instruction Set Computer)
→ 복잡한 명령어 집합을 활용하는 컴퓨터

복잡하고 다양한 수의 가변 길이 명령어를 활용
→ 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미
→ 메모리를 절약할 수 있다 → 컴파일된 프로그램의 크기가 작다 

- 치명적인 단점 존재
1. 명령어의 규격화가 어려워 파이프라이닝이 어렵다
2. 대다수의 복잡한 명령어는 사용 빈도가 낮다

### RISC

RISC(Reduced Instruction Set Computer)

단순하고 적은 수의 고정 길이 명령어 집합을 활용

- 주의해야 하는 것
1. 원활한 파이프라이닝을 위해 ‘명령어 길이와 수행 시간이 짧고 규격화’되어 있어야 한다
2. 복잡한 기능을 지원하는 명령어를 추가하기 보다 ‘자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것’이 중요하다

→ 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향

메모리 접근을 단순화하고 최소화함(load, store)
→ 레지스터를 적극 활용
→ 명령어 개수가 적으므로 CISC보다 많은 명령으로 프로그램을 작동시킴

## 비교

| CISC | RISC |
| --- | --- |
| 복잡하고 다양한 명령어 | 단순하고 적은 명령어 |
| 가변 길이 명령어 | 고정 길이 명령어 |
| 다양한 주소 지정 방식 | 적은 주소 지정 방식 |
| 프로그램을 이루는 명령어의 수가 적음 | 프로그램을 이루는 명령어의 수가 많음 |
| 여러 클럭어 걸쳐 명령어 수행 | 1클럭 내외로 명령어 수행 |
| 파이프라이닝하기 어려움 | 파이프라이닝하기 쉬움 |