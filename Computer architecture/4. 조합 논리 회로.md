# 4.1 조합 논리 회로

## 가산기

- 반가산기(half adder)

반가산기는 두 개의 입력을 받아 덧셈을 수행하며, 자리 올림수를 처리하지 않는다
반가산기는 '반쪽짜리 가산기'라는 의미를 지닌다

반가산기 진리표 작성:
입력 A와 B의 모든 경우의 수를 나열한다 
-> (00, 01, 10, 11)
진리표의 출력은 합계(S)와 자리 올림수(C)로 나뉜다
각 입력 조합에 따른 출력을 정리한다

반가산기 회로 설계:
합계 S는 XOR 게이트를 사용하여 계산된다
자리 올림수 C는 AND 게이트를 통해 계산된다
반가산기의 회로는 XOR와 AND 게이트로 구성된다

- 전가산기(full adder)

전가산기는 세 개의 입력을 받아 덧셈을 수행하고, 자리 올림수를 처리할 수 있다
입력이 세 개인 이유는 덧셈 과정에서 발생하는 캐리를 포함하기 때문이다
전가산기는 두 개의 반가산기와 하나의 OR 게이트로 구성된다

전가산기 진리표 작성:
세 개의 입력 X, Y, Z에 대한 모든 조합을 나열한다
-> (000, 100, 010, 110, 001, 101, 011, 111)
각 조합에 따른 합계(S)와 자리 올림수(C)를 기록한다
진리표를 통해 캐리와 합계를 확인한다

전가산기의 회로 설계:
합계 S는 X, Y, Z를 XOR 게이트를 통해 계산한다
S는 짝수 패리티라고도 부른다, 1의 개수가 홀수면 1을 출력하는 방식
자리 올림수 C는 두 가지 경로를 통해 계산된다
Cout는 A AND B + Cin (A XOR B)
-> 입력 3개 중 2개 이상 1이 나오면 출력으로 1이 나온다는 뜻이다
캐리가 발생하려면 무조건 입력에 1이 두 개 이상이어야 한다
전가산기는 두 개의 반가산기와 하나의 OR 게이트로 구성된다

- 멀티 비트 가산기

하위비트의 Cout이 상위비트의 Cin으로 입력된다
4비트 전가산기의 경우에는 리플캐리 방식을 사용한다

## 감산기

- 감산기의 원리

A - B = A + (-B) = A + not(B) + 1 = A + (B XOR 1) + 1

A + not(B) + 1
-> 상위비트에서 빼기 힘들기 때문에 비트 반전을 주어
먼저 1비트를 빼주고 나중에 1비트를 더하는 방식으로 계산하는 것을 말한다

A + (B XOR 1) + 1
-> not(B) 라는 것이 비트 반전을 주는 것이기 때문에 이거 자체가
(B XOR 1) 즉 0 이거나 1이라는 뜻으로 선택적으로 뒤집는 것으로 같은 의미이다

- 반감산기

비트의 감산 과정 중 빌려오는 과정에서 상위 비트에서 1을 빌려오는 형식이다
입력이 두 개일 경우 반감산기이다
반감산기는 XOR 게이트와 NOT이 들어간 AND 게이트로 구성된다

- 전감산기

입력이 3개일 경우 전감산기이다
전감산기의 모든 경우의 수를 진리표에 표현한다
X, Y, Z의 조합에 따른 감산 결과를 분석한다
각 조합에 따른 차이(D)와 빌려온 수(B)의 변화를 설명한다
전감산기는 반감산기 두 개와 OR 게이트로 구성된다

- 감/가산기

Cin이 0이면 가산기이고 Cin이 1이면 감산기이다
뺄셈을 할 때는 Sub 신호에 1을 입력해서 뺄셈을 하는 것이다
이렇게 Cin을 조절해서 감산기와 가산기 모두 수행 가능하다

## 상태비트(status) 회로

- 상태 레지스터

cpu 내부의 상태를 저장하는 레지스터를 말한다
Negative(N), Zero(Z), Overflow(V), Carry(C) 가 있다

C: Cout을 말한다
V: 마지막 두 Cout을 XOR 해서 Overflow를 확인한다
N: S의 부호가 무엇인지 N을 확인한다
Z: 모든 S의 합이 0인지를 NOR을 통해 확인한다

## 오버플로우 판별

- 캐리와 오버플로우의 차이

캐리는 정상적인 자리 올림 수가 발생되는 과정에서 나오는 현상이다
오버플로우는 표현할 수 있는 수의 범위를 벗어나는 경우에 발생한다
캐리는 연산의 결과에 영향을 미치지 않는다
1 + 127을 계산할 때, 128이 아닌 -128이 출력되는 경우가 발생하는데,
이는 오버플로우가 발생했음을 나타내며 이는 잘못된 결과를 초래한다

- 오버플로우 발생하는 경우

같은 부호의 숫자들을 더하는 경우 오버플로우가 발생한다
양수 + 양수 / 음수 + 음수 를 더하는 경우
다른 부호의 숫자들을 더한다면 절댓값이 작아지기 때문에 오버플로우가 발생하지 않는다

2개의 전가산기 Cout 출력 결과를 XOR해보면 오버플로우 여부를 확인할 수 있다
1이 나오면 오버플로우이고, 0이 나오면 정상적인 계산 결과이다


# 4.2 논리식의 간소화: Karnaugh map(K-map)

## k-map

카르노 맵은 논리식의 간소화를 위한 도구이다
변수의 수에 따라 맵의 형태가 달라진다
0인 부분은 해당 변수의 NOT을 나타낸다
1인 부분은 해당 변수를 그대로 나타낸다
카르노 맵은 2의 지수승개인 1, 2, 4, 8개 등으로 묶어서 이들을 공통적으로 묶어서 표시한다
1인 부분을 많이 중복해도 상관없으니 변수를 최대한 줄이는 방식으로 크게 묶는 것이 좋다

a\bc인 맵에서 a 는 0, 1로 표시하지만
bc는 00, 01, 11, 10 순서로 표시한다
인접한 셀들끼리 1비트씩만 다르게 표시해야 변수들을 묶을 때
변수들을 삭제해서 표시할 수 있기 때문이다

- 1비트 전가산기

k-map for Sum:
Sum = A'B'C + ABC' + ABC + A'BC'
    = A(B XOR C) + A'(B XOR C)
    = A XOR B XOR Cin

k-map for Cout:
Cout = AB + CinA + CinB
     = AB + Cin(A + B)

- Don't Care

특정 입력값을 고려할 필요가 없는 경우
출력에 영향을 전혀 미치지 않는 입력의 경우에
필요하다면 그룹핑을 할 때 1로 생각할 수 있다

- Dual k-map

곱의 합(SoP, Sum of Product):
    최소항(민텀)을 사용한다
    f = y'z + xz'
    원래 하던대로 1을 묶어서 f를 구하는 방식이다

합의 곱(PoS, Product of Sum):
    최대항(맥스텀)을 사용한다
    f' = x'y'z' + x'yz' + x'yz + xyz
       = x'z'(y' + y) + yz(x + x')
       = yz + x'z'
    f = (f')' = (yz + x'z')' = (y' + z')(x + z)
    f'인 0을 묶는 것이 더 구하기 쉬울 때 f'을 구하고 (f')'을 해서 f를 구하는 방식이다

### NAND 게이트

드모르강의 법칙을 이용하여 And-or 회로를 NAND 게이트로 바꾸는 것이다
(abc)' = a' + b' + c'
(a + b + c)' = a'b'c' 이렇게 NAND 게이트로 바꿔도 동일한 기능을 수행한다