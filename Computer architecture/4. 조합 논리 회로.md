# 4.1 조합 논리 회로

## 가산기

- 반가산기(half adder)

반가산기는 두 개의 입력을 받아 덧셈을 수행하며, 자리 올림수를 처리하지 않는다
반가산기는 '반쪽짜리 가산기'라는 의미를 지닌다

반가산기 진리표 작성:
입력 A와 B의 모든 경우의 수를 나열한다 
-> (00, 01, 10, 11)
진리표의 출력은 합계(S)와 자리 올림수(C)로 나뉜다
각 입력 조합에 따른 출력을 정리한다

반가산기 회로 설계:
합계 S는 XOR 게이트를 사용하여 계산된다
자리 올림수 C는 AND 게이트를 통해 계산된다
반가산기의 회로는 XOR와 AND 게이트로 구성된다

- 전가산기(full adder)

전가산기는 세 개의 입력을 받아 덧셈을 수행하고, 자리 올림수를 처리할 수 있다
입력이 세 개인 이유는 덧셈 과정에서 발생하는 캐리를 포함하기 때문이다
전가산기는 두 개의 반가산기와 하나의 OR 게이트로 구성된다

전가산기 진리표 작성:
세 개의 입력 X, Y, Z에 대한 모든 조합을 나열한다
-> (000, 100, 010, 110, 001, 101, 011, 111)
각 조합에 따른 합계(S)와 자리 올림수(C)를 기록한다
진리표를 통해 캐리와 합계를 확인한다

전가산기의 회로 설계:
합계 S는 X, Y, Z를 XOR 게이트를 통해 계산한다
S는 짝수 패리티라고도 부른다, 1의 개수가 홀수면 1을 출력하는 방식
자리 올림수 C는 두 가지 경로를 통해 계산된다
Cout는 A AND B + Cin (A XOR B)
-> 입력 3개 중 2개 이상 1이 나오면 출력으로 1이 나온다는 뜻이다
캐리가 발생하려면 무조건 입력에 1이 두 개 이상이어야 한다
전가산기는 두 개의 반가산기와 하나의 OR 게이트로 구성된다

- 멀티 비트 가산기

하위비트의 Cout이 상위비트의 Cin으로 입력된다
4비트 전가산기의 경우에는 리플캐리 방식을 사용한다

## 감산기

- 감산기의 원리

A - B = A + (-B) = A + not(B) + 1 = A + (B XOR 1) + 1

A + not(B) + 1
-> 상위비트에서 빼기 힘들기 때문에 비트 반전을 주어
먼저 1비트를 빼주고 나중에 1비트를 더하는 방식으로 계산하는 것을 말한다

A + (B XOR 1) + 1
-> not(B) 라는 것이 비트 반전을 주는 것이기 때문에 이거 자체가
(B XOR 1) 즉 0 이거나 1이라는 뜻으로 선택적으로 뒤집는 것으로 같은 의미이다

- 반감산기

비트의 감산 과정 중 빌려오는 과정에서 상위 비트에서 1을 빌려오는 형식이다
입력이 두 개일 경우 반감산기이다
반감산기는 XOR 게이트와 NOT이 들어간 AND 게이트로 구성된다

- 전감산기

입력이 3개일 경우 전감산기이다
전감산기의 모든 경우의 수를 진리표에 표현한다
X, Y, Z의 조합에 따른 감산 결과를 분석한다
각 조합에 따른 차이(D)와 빌려온 수(B)의 변화를 설명한다
전감산기는 반감산기 두 개와 OR 게이트로 구성된다

- 감/가산기

Cin이 0이면 가산기이고 Cin이 1이면 감산기이다
뺄셈을 할 때는 Sub 신호에 1을 입력해서 뺄셈을 하는 것이다
이렇게 Cin을 조절해서 감산기와 가산기 모두 수행 가능하다

## 상태비트(status) 회로

- 상태 레지스터

cpu 내부의 상태를 저장하는 레지스터를 말한다
Negative(N), Zero(Z), Overflow(V), Carry(C) 가 있다

C: Cout을 말한다
V: 마지막 두 Cout을 XOR 해서 Overflow를 확인한다
N: S의 부호가 무엇인지 N을 확인한다
Z: 모든 S의 합이 0인지를 NOR을 통해 확인한다

## 오버플로우 판별

- 캐리와 오버플로우의 차이

캐리는 정상적인 자리 올림 수가 발생되는 과정에서 나오는 현상이다
오버플로우는 표현할 수 있는 수의 범위를 벗어나는 경우에 발생한다
캐리는 연산의 결과에 영향을 미치지 않는다
1 + 127을 계산할 때, 128이 아닌 -128이 출력되는 경우가 발생하는데,
이는 오버플로우가 발생했음을 나타내며 이는 잘못된 결과를 초래한다

- 오버플로우 발생하는 경우

같은 부호의 숫자들을 더하는 경우 오버플로우가 발생한다
양수 + 양수 / 음수 + 음수 를 더하는 경우
다른 부호의 숫자들을 더한다면 절댓값이 작아지기 때문에 오버플로우가 발생하지 않는다

2개의 전가산기 Cout 출력 결과를 XOR해보면 오버플로우 여부를 확인할 수 있다
1이 나오면 오버플로우이고, 0이 나오면 정상적인 계산 결과이다