#OS

>operating system concepts 10th 1장을 토대로 정리하였습니다.

# 1️⃣ Events(이벤트 처리)

이전 OS 개론(1)에서 나왔다시피 컴퓨터 하드웨어는 기본적으로 CPU, 메모리, I/O device로 구성되어 있습니다.
CPU와 I/O device는 동시에 실행될 수 있는데요. 장치 컨트롤러는 CPU에게 이벤트 발생을 알리는데, 이벤트 발생을 알리는 것을 ==**인터럽트**(Interrupt)==라고 부릅니다.

인터럽트는 '방해하다’라는 뜻으로, 컴퓨터에서는 신호를 보내 이벤트 발생을 알리는 것을 의미합니다.
보통 컴퓨터는 여러 작업을 동시에 처리하는데, 이때 당장 처리해야 하는 일이 생겨서 기존의 작업을 잠시 중단해야 하는 경우 인터럽트 신호를 보내게 됩니다.
그러면 커널은 작업을 멈추고 인터럽트를 처리한 뒤 다시 기존 작업으로 돌아오게 됩니다.

인터럽트는 하드웨어나 소프트웨어에 의해 발생할 수 있으며,

소프트웨어에 의해 발생하는 인터럽트는 ==**트랩**(Trap)==과 ==**시스템 콜**==이 있습니다. 

하드웨어의 경우 시스템 버스(System bus)를 통해 CPU에 신호를 보냄으로써 인터럽트를 발생시킵니다.

![](https://csstudy.s3.ap-northeast-2.amazonaws.com/OS%20%EA%B0%9C%EB%A1%A0%282%29%20/%20Pasted%20image%2020250106112629.png)

### Common Functions of Interrupts

컴퓨터는 여러 작업을 동시에 처리하는데, 만약 CPU가 인터럽트 신호를 받으면, 앞서 말했듯이 하던 일을 잠시 멈추고 메모리의 어떤 고정된 위치(Fixed location)를 찾게됩니다.

이 위치는 **인터럽트 벡터**(Interrupt vector)에 저장되어 있습니다.

>❓**인터럽트 벡터?**
	인터럽트 백트는 인터럽트를 처리할 수 있는 **서비스 루틴**(Service routine)들의 주소를 가지고 있는 공간을 말함(진입점 주소만 제공)
	인터럽트 번호는 운영체제가 결정함.

>**리눅스에서 인터럽트 번호**  
	 0 ~ 31 : 예외상황 인터럽트  
	32 ~ 47 : 하드웨어 인터럽트  
	128 : 시스템콜

##### 그렇다면 인터럽트 처리 방식에 대해 알아봅시다!

인터럽트가 발생하면 CPU는 사전에 정의된 방식으로 인터럽트 핸들러를 호출하여 문제를 처리합니다.
CPU는 테이블에서 찾은 예외 핸들러의 시작 주소로 점프하여, 커널이 작성해 둔 예외 처리 코드를 실행하게 됩니다.

인터럽트가 발생했을 때, CPU가 어떤 코드(인터럽트 핸들러)를 실행할지를 결정하기 위해서는, 먼저 해당 인터럽트 번호에 대응하는 핸들러의 시작 주소를 알아야 합니다. 
이 정보를 저장해 놓은 자료구조가 바로 ==인터럽트 벡터 테이블(IVT)== 입니다

> **IVT와 인터럽트 핸들러의 관계는...**
> 
> 1. IVT에는 인터럽트 핸들러의 주소가 저장되어 있음
> 	인터럽트 번호 → 핸들러 코드가 시작되는 메모리 주소
> 2. 인터럽트 발생  
> 	CPU가 “인터럽트 번호”를 확인하고, 해당 번호에 맞는 엔트리를 IVT에서 조회
> 3. 핸들러 실행  
> 	IVT에 기록된 핸들러의 시작 주소로 점프(분기)하여 인터럽트 처리를 수행

	즉, IVT는 인터럽트 핸들러를 호출하기 위한 주소 안내표 역할을 하고, 실제로 인터럽트를 처리하는 로직은 인터럽트 핸들러(ISR) 쪽에 구현되어 있다고 볼 수 있습니다.

이렇게 인터럽트를 처리하고나면 CPU는 다시 원래 작업으로 돌아오게 됩니다. 
어떤 값을 0으로 나누는 것(Division by zero)도 인터럽트이며, 이러한 내부 인터럽트(Internal interrupt)는 예외(Exception)라고 부릅니다.

참고로 system call의 종류는 다음과 같습니다.

![500](https://csstudy.s3.ap-northeast-2.amazonaws.com/OS%20%EA%B0%9C%EB%A1%A0%282%29%20/%20Pasted%20image%2020250106114208.png)

# 2️⃣ Timer

Timer는 두 가지 종류가 있습니다.

1. **CPU 내부의 시계**
2. **운영체제에서 사용하는 시계**

**CPU 내부의 시계**는 ==**클럭(Clock)**==이라고 하며, CPU가 명령을 처리하는 기본적인 동작 주기를 제공합니다.
예를 들어, 4.3GHz 클럭 속도라면, CPU는 초당 43억 회의 클럭 사이클을 수행할 수 있다는 뜻입니다.
이러한 클럭은 CPU 내부의 각 구성 요소(산술 논리 유닛(ALU), 레지스터 등)와 외부 장치 간의 동기화를 유지합니다.

**운영체제에서 사용하는 시계**는 주기적으로 ==**타이머 인터럽트**==를 발생시켜 시계를 관리합니다.
타이머 인터럽트는 일정한 주기로 발생하며, 이를 통해 CPU는 현재 시간을 계산하거나 프로세스를 스케줄링합니다.
역할로는 시스템 시간 관리, 프로세스 스케줄링, 디바이스 동기화가 있습니다.

# 3️⃣ Resource Management

리소스는 사용자가 작업을 하기 위한 자원(CPU,메모리,입출력장치)을 말합니다.

이러한 자원들의 관리 필요성은 다음과 같습니다.

- **자원의 한정성** : 컴퓨터의 자원은 한정되어 있으므로, 여러 프로세스가 동시에 실행되는 환경에서 적절히 관리하지 않으면 병목 현상이 발생하거나 특정 프로세스가 자원을 독점할 수 있습니다.
- **공정한 사용** : 모든 프로세스가 공정하게 자원을 사용할 수 있도록 보장해야 합니다.
- **효율성** : 시스템의 성능을 극대화하려면 자원을 낭비 없이 효율적으로 할당해야 합니다.
- **안정성** : 잘못된 자원 관리로 인해 데드락(Deadlock)이나 자원 부족으로 시스템이 비정상적으로 작동하는 상황을 방지해야 합니다.

운영 체제는 고객(**프로세스**)이 효율적이고 공정하게 자원을 사용할 수 있도록 중간 관리자의 역할을 수행하며, 시스템의 성능과 안정성을 유지합니다.

이를 위해 운영체제는 Process, Memory, Storage, File-System, Mass-Storage Management를 수행합니다. 더 자세한 건 각 자원 관리에 대해 따로 정리해보겠습니다.

# 4️⃣ Caching

앞 페이지에서 컴퓨터는 폰 노이만 구조로 이루어져 있다고 했었습니다.
폰 노이만 구조는 CPU가 **명령어를 Fetch → Decode → Execute**하는 단계를 반복적으로 수행하는걸 말하는데요.
이는 CPU와 메모리 사이의 단일 버스를 통해 데이터와 명령어를 주고받는 구조라고 말할 수 있습니다.

이 구조의 특징인 **단일 버스**는 데이터와 명령어를 동시에 처리하지 못하기 때문에 병목(Bottleneck)이 발생할 수 있습니다. 이를 **폰 노이만 병목 현상**(Von Neumann Bottleneck)이라 부르는데요.

병목 현상의 원인으로는 메모리의 접근 속도가 CPU의 연산 속도보다 느리고, CPU가 더 많은 연산을 빠르게 처리할 수 있어도 메모리로부터 데이터를 가져오는 데 걸리는 시간이 전체 성능을 제한하기 때문입니다.

위의 CPU와 메모리 간의 속도를 줄이기 위해 ==**캐시 메모리(Cache Memory)**==가 도입되었습니다.
캐시 메모리는 CPU 내부나 가까운 위치에 배치되어 **가장 자주 사용되는 데이터**(명령어 및 연산 데이터)를 저장합니다.
캐시는 굉장히 작은 저장장치로 SRAM(Static RAM) 기술을 사용하여 DRAM(일반 메모리)보다 훨씬 빠른 속도를 제공해주어 병목현상을 해결해 줄 수 있습니다.

작동 원리로는 다음과 같습니다.

1. CPU가 데이터를 요청하면 먼저 캐시를 확인합니다(**cache hit**)
2. 캐시에 데이터가 없는 경우 메모리에서 데이터를 가져와 캐시에 저장하고, CPU가 이를 사용합니다(**cache miss**)

여기서 캐시 성능을 정량적으로 평가하거나 분석하기 위해서 기대값을 사용할 수 있습니다.
캐시 메모리의 기대값을 계산하면 성능 병목을 정량적으로 평가하고, 효율적인 설계와 최적화를 지원할 수 있습니다.

