# 운영체제 기초 정리

### 0. 역할

- 개념 : OS는 컴퓨터 시스템의 소프트웨어와 하드웨어 자원을 관리하고, 사용자가 컴퓨터를 쉽게 사용할 수 있도록 도와주는 시스템 소프트웨어

### 1. 자원관리

- CPU, Memory, 저장 장치 등을 효율적으로 관리하여, 여러 응용 프로그램이 동시에 실행될 때 자원을 적절히 분배

### 2. CPU 스케줄링

- **First Come First Served**
  - 먼저 요청한 프로세스부터 처리
    - 긴 작업이 먼저 처리되면 뒤의 작업이 오래 대기
    - 해당 스케쥴링을 사용하면서 긴 시간 작업이 들어온다면 작업을 분리하는 로직이나 킨 시간에 제한을 두고 큐와 같은 저장소 사용
  - **예시**
    - 들어온 순서: P1(10ms), P2(5ms), P3(2ms)
    - 대기 시간: P1(0ms, 바로 실행), P2(10ms), P3(10+5=15ms)
    - 평균 대기 시간: (0 + 10 + 15) / 3 = 8.33ms
- **Shortest Job First**
  - 실행 시간이 가장 짧은 작업부터 처리
    - 긴 작업이 계속 기다리는 starvation problem 발생
  - **예시**
    - 들어온 순서: P1(10ms), P2(5ms), P3(2ms)
    - 대기 시간: P3(0ms, 바로 실행), P2(2ms), P1(2+5=7ms)
    - 평균 대기 시간: (0 + 2 + 7) / 3 = 3ms
- **Round Robin**
  - 각 프로세스가 정해진 시간만큼(타임 슬라이스) 교대로 실행
  - 도착 시간이 있으면 이를 고려하여 queue에 process가 기다림
  - **예시 (타임 슬라이스: 4ms)**
    - 들어온 순서: P1(10ms), P2(5ms), P3(2ms)
    - 처리 순서:
      - P1(4ms) → P2(4ms) → P3(2ms, 완료) → P1(4ms) → P2(1ms, 완료) → P1(2ms, 완료)
    - P1의 대기 시간: 4 + 2 + 1 = 7
    - P2의 대기 시간: 4 + 2 + 4 = 10
    - P3의 대기 시간: 8
    - 평균 대기 시간: 25 / 3 = 8.33ms

### 3. 메모리 관리

- **가상 메모리**
  - 물리적 메모리의 크기에 관계없이 실행 파일이 실행되도록 지원
  - 모든 작업은 실제 메모리에서 일어나고 이 과정은 매핑 테이블에서 일어나는데 MMU를 통해서 일어남.
  - **페이지 교체 알고리즘**
    - **First In First Out**
      - 가장 오래된 페이지를 먼저 교체
      - 자주 사용되는 페이지도 오래된 순서로 교체 가능
    - **Least Recently Used**
      - 가장 오래 사용되지 않은 페이지를 교체
      - 자주 사용하는 페이지를 메모리에 유지, 효율적이지만 구현 복잡
- **메모리 단편화(Fragmentation)**
  - 연속적인 공간 부족으로 프로그램 실행이 어려운 문제를 해결하기 위해 페이징 기술 적용
  - **종류**
    - **내부 단편화**: 고정 크기 블록 단위 할당 (작은 메모리 요청 시 남는 공간 발생)
    - **외부 단편화**: 메모리 블록 할당 및 해제되는 과정에서 남는 조각들로 인해 큰 연속적인 메모리 처리 안됨
      - 4KB + 6KB 공간 남아도 8KB 처리가 안됨
  - **페이징 기술 적용**
    - **Paging**: 메모리를 동일한 크기의 페이지 단위로 나누고 페이지 프레임 단위로 적재 → 외부 단편화 방지
    - **Segmentation**: 프로그램의 논리적 구조 (code, data, stack)을 분리해서 관리 → 단편화 문제를 줄이면서 논리적 관리 가능

### 4. 저장 장치 관리

- **파일 시스템**
  - 데이터를 계층적 구조 (파일과 디렉토리)로 저장하고 관리
  - NTFS: 윈도우의 기본 파일 시스템
  - ext4: 리눅스의 기본 파일 시스템
- **디스크 스케쥴링**
  - 읽기/쓰기 작업을 최적화하여 디스크 접근 시간을 최소화
  - **구성 요소**
    - 탐색 시간(Seek Time) : 디스크 헤드가 적절한 트랙으로 이동하는데 걸리는 시간
    - 회전 지연(Rotational Latency) : 데이터가 디스크 헤드 아래로 올 때 까지 기다리는 시간
    - 데이터 전송 시간 : 디스크에서 데이터를 전송하는 시간
  - **알고리즘**
    - **Shortest Seek Time First**: 가장 가까운 요청부터 처리 → starvation problem 발생 가능
    - **SCAN**: 디스크 헤드가 한 방향으로 이동하며 요청 처리 → 기아 상태 방지 가능
      - 현재 디스크 위치가 50, 방향이 증가하는 쪽으로 간다고 할 때 [10, 45, 70, 90] 이 요청이면 처리를 70 → 90 → 45 → 10 (끝에 도달하게 되면 방향을 반대로 바꿈)

### 5. 입출력 관리

- **Buffering**
  - 데이터를 임시 저장하여 입출력 장치의 속도 차이를 완화
  - **입력 버퍼링** : 입력 장치에서 데이터를 읽어 들여 버퍼에 저장, CPU는 버퍼에서 데이터를 가져와 사용
  - **출력 버퍼링** : CPU가 생성한 데이터를 버퍼에 임시 저장. 버퍼가 가득차거나 조건이 충족되면 프린터 혹은 디스크 같은 출력 장치로 데이터를 전송
  - 대부분의 버퍼는 메인 메모리 (RAM)에 저장됨
  - 종료
    - 단일 버퍼링 : 하나의 버퍼
    - 이중 버퍼링 : 하나는 데이터를 읽고 씀, 다른 버퍼는 CPU가 처리
    - 순환 버퍼링 : 원형 배열로 하여 버퍼를 사용 (데이터 스트리밍과 같은 대구모 연속 작업에 적합)
      - 순환 버퍼링에서는 기본적으로 고정(크기 설정시 데이터량이나 처리 속도에 따 설정)
- **Caching**
  - 자주 사용하는 데이터를 메모리에 저장하여 접근 속도 향상 (매번 데이터를 디스크에서 읽어오면 성능이 저하됨.)
  - CPU가 데이터 요청 시 해당 데이터를 먼저 탐색 → 캐시에 데이터가 존재하는 캐시 히트 / 캐시에 데이터가 없으면 캐시 미스
  - 캐싱의 종류
    - 메모리 캐시 : 주로 CPU, RAM 간의 데이터 전송 속도를 높이기 위해 사용
      - L1, L2, L3 캐시로 구분하하면 L1이 가장 빠름
    - 디스크 캐시 : 주로 사용하는 데이터를 RAM에 저장
    - 웹 캐시 : 브라우저나 프록시 서버가 자주 사용하는 웹 콘텐츠를 네트워크 대역폭을 줄이고 페이지 로딩 시간을 단축함.

### 6. 사용자와 하드웨어 간 인터페이스 제공

- **CLI**: 명령어 입력으로 시스템 제어
- **GUI**: 시각적 요소로 시스템 제어
- **API**: 응용 프로그램 개발자가 운영체제 기능 사용

### 7. 프로세스

- 실행 중인 프로그램의 인스턴스 (운영체제가 관리하는 가장 기본적인 단위)
- **구성 요소**
  - 코드 섹션
  - 데이터 섹션 : 전역 변수, 초기화된 데이터
  - 스택 : 함수 호출과 관련된 정보 (지역 변수, 매개 밴수, 반환 주소)
  - 힙 : 동적으로 할당된 메모리
  - 프로세스 제어 블록 (PCB) : 프로세스 상태, PID, CPU 레지스터 정보, 스케줄링 정보, 메모리 관리 정보 등이 포함
- **프로세스 간 통신 (IPC)** : 각 프로세스는 독립적이기 때문에 데이터 공유를 위한 매커니즘 필요
  - **Pipe**
    - 단방향 통신 FIFO
    - 주로 부모-자식 프로세스 간 통신에 사용됨
    - 프로세스는 파이프의 읽기 끝, 쓰기 끝을 닫아야 함
    - 두 프로세스는 동일한 공통 부모 프로세스를 가져야
  - **Message Queue**
    - 커널이 관리하는 큐에 메시지를 저장하여 프로세스 간 데이터를 전달
    - 프로세스는 식별자를 통해 큐에 넣거나 가져옴
    - FIFO, 우선순위 기반으로 삽입하며 부모-자식 관계가 없어도 통신 가능
    - 커널 메모리에 사용에 크기 제한 있음
  - **Shared Memory**
    - 가장 빠른 매커니즘으로 특정 메모리 영역을 공유 → 할당한 메모리 영역을 다른 프로세스가 직접 접근
    - 속도가 빨라 대량의 데이터 처리에 적하지만 동기화 문제가 발생할 수 있어 세마포어 혹은 뮤텍스로 접근 제어 필요
  - **Socket**
    - 네트워크 기반 통신
    - 서버-클라이언트 모델에서 일반적으로 활

### 8. 스레드

- 프로세스 내부에서 실행되는 작업 단위 (프로세스는 여러 스레드를 가질 수 있음)
- 스레드는 같은 프로세스 내에서 자원을 공유 (생성, 관리, 스위칭 비용 적음)
- **구성 요소**
  - 스레드 ID : 고유 식별자
  - PC : 스레드의 현재 명령어 주소
  - 레지스터와 스택 : 독립적 관리
  - 공유 메모리 : 부모 프로세스와 공유하는 힙, 코드, 데이터
- 멀티스레딩 (하나의 프로세스에서 여러 스레드가 동시에 실형) 구현
  - 사용자 스레드
    - 커널과 독립적으로 사용자 공간에서 관리
    - 빠르지만 커널 지원 부족 시 비효율적
  - 커널 스레드
    - 커널에서 직접 관리
    - 안정적이지만 비용 증가

### 9. 컨텍스트 스위칭

- 컨택스트 : 프로세스나 스레드의 실행 상태를 나타내는 데이터
- 하나의 프로세스에서 다른 프로세스로 전환할 때, 현재 작업 상태를 저장하고 새로운 작업의 상태를 복원하는 과정
- 실행 상태 저장과 복원
- 상세 과정
  1. 실행 중인 프로세스의 상태를 Process Control Block에 저장 (CPU 레지스터 값, 프로그램 카운터, 스택 상태, 프로세스 상태)
  2. 새로운 프로세스를 선택함 (스케줄링 알고리즘에 따라 선택)
  3. 선택된 프로세스의 상태를 복원하여 실행 재개
- 비용 발생 이유
  - 상태 저장과 복원의 오버헤드 : CPU 레지스터, 프로그램 카운터, 메모리 매핑 등을 저장하고 복원하는 작업이 필요함
  - 캐시 무효화 : CPU 캐시는 프로세스 변경 시 시고전 데이터를 사용할 수 없으므로 새롭게 로드
  - 파이프라인 비효율 : 현대 CPU는 파이프라인 구조로 동작하므로, 새로운 프로세스를 실행할 때 파이파리인이 비워짐.
