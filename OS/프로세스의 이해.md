# 1️⃣ 프로세스의 개념

프로세스란 무엇일까요?

프로세스는 실행중인 프로그램으로 **운영체제에서 프로그램을 실행하는 독립된 실행 단위**를 의미합니다.
프로세스는 프로세스를 실행하기 위한 작업의 최소 단위인 테스크를 완료하기 위해서 다음과 같은 **자원**이 필요합니다.
- CPU의 점유
- 메모리(memory)
- 파일(files)
- 입/출력 장치(I/O devices)

OS 개론에서 한 번 봤다시피 컴퓨터는 load → fetch → execute 로 진행되는데
이를 기반으로 프로세스를 정의하자면 메모리 위에 적재된 프로그램을 프로세스라고 정의할 수 있습니다.

# 2️⃣ 프로세스 구조

프로세스의 구조로는 아래 사진으로 알아볼 수 있습니다.
![[메모리에서 프로세스.png]]
프로세스에서는 text, data, heap, stack 영역이 있고 각 영역이 설명은 다음과 같습니다.

- **Text Section** : 실행가능한 코드를 저장하는 공간
- **Data Section** : 전역 변수를 저장하는 공간
- **Heap Section** : 프로그램 실행동안 동적으로 할당되는 변수가 저장되는 공간
- **Stack Section** : 함수가 실행되는 동안 지역변수가 저장되는 임시 공간, 대표적으로 함수 매개변수, 리턴 주소, 지역 변수 등이 포함됨

즉, stack 영역에는 지역 변수가 들어가고 이는 dynamic 합니다.
전역 변수는 data에 들어가게 되고 이는 static합니다.
heap 영역에는 동적 변수(new로 새로운 메모리를 할당할 때)가 들어가게되고 이는 dynamic합니다.

**다시 정리하자면...**
전역변수는 프로그램이 실행될 때 할당받으면 그 공간을 그대로 가지고 있기에 static하게 할당 됩니다.
	→ 한 번 할당되면 자기 자리가 바뀌지 않고 그대로 있음
	→ data 영역

나머지는 dynamic하게 할당됩니다.
	→ 실행중에 필요할때 변수에 대한 공간이 할당 되었다가 후에 회수임
	→ 지역 변수, 동적 자료


**코드를 통해 프로세스의 영역에 대해 알아봅시다!**

```c++
#include <iostream>
#include <cstdlib>

using namespace std;

// 전역 변수
int x;
int y = 15;

int main(int argc, char *argv[]) {
	int* values;
	int i;

	// 동적 메모리 할당
	values = new int[5]; 

	// 값 초기화
	for (i = 0; i < 5; i++) {
		values[i] = i;
	}

	// 값 출력
	for (i = 0; i < 5; i++) {
		cout << values[i] << " ";
	}

	cout << endl;

	// 메모리 해제
	delete[] values;

	return 0;
}
```

- Stack Section : main, values, i
- Heap Section : values = new int[5]; 
- Data Section  
    - uninitialized data : x
    - initialized data : y
- Text Section : 코드 텍스트

위 코드를 컴파일하고 영역간 사이즈를 출력하면 아래와 같이 나오게 됩니다.

![[Pasted image 20250119195753.png]]

현재 mac OS 환경에서 실행했을때 위 코드의 text와 data 영역 사이즈는 16KB인 것을 확인할 수 있습니다.

# 3️⃣ 프로세스 상태

프로세스는 프로그램의 인스턴스(시작과 끝이 있는 것을 말함)라고 말할 수 있는데요
프로세스의 상태는 다음과 같이 이어집니다.

![[프로세스 상태.png]]

- New : 프로세스가 생성된 상태
- Running : 프로세스가 수행되는 상태
- Waiting : 프로세스 이벤트가 발생되어 입/출력 완료를 기다리는 상태
- Ready : 프로세스가 프로세서에 의해 실행되기를 기다리는 상태(언제라도 실행 가능)
- Terminated : 프로세스 실행 종료 상태


# 4️⃣ Process Control Block

운영체제에서 각각의 프로세스는 PCB(Process Control Block)로 표현됩니다. 
PCB는 하나의 프로세스에 연관된 정보들을 포함하는데요. 즉, PCB는 프로세스에 관한 정보 블록을 말합니다.

→ 프로세스가 하나 생성되면 이를 관리하기 위해 모든 정보를 담은 테이블
	_(예를 들어 어떤 프로세스가 메모리 어디에 올라와 있는지 이런 것들)_

프로세스가 생성될 때마다 고유의 PCB가 생성되고, 프로세스가 완료되면 PCB도 함께 제거됩니다.

PCB에는 아래와 같은 정보를 가지고 있습니다.

- **프로세스 상태(Process State)** : new, ready, running, waiting, terminated 상태 중 하나에 해당됨
- **프로그램 카운터(Program Counter)** : 메모리의 다음 명령어 주소를 저장함
- **CPU 레지스터(CPU registers)** : IR(Instruction Register), DR(Data Register), PC(Program Counter)와 같은 저장공간이 포함됨
- **CPU 스케줄링 정보(CPU-scheduling information)** : 프로세스 실행 순서를 정하는 정보
- **메모리 관리 정보(Memory-management information)**
- **통계 정보(Accounting Information)** : 프로세스의 실행, 시간 제한, 실행 ID 등에 사용되는 CPU양의 정보
- **입/출력 상태 정보(I/O status information)**

PCB가 위와 같은 정보를 가지고 있는 주된 이유는 프로세스가 실행하다 중간에 중단되었을때, 그때의 프로세스의 정보를 저장하기 위함입니다.
![[PCB.png|500]]

이렇게 수행 중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것을 Context Switching(문맥 교환)이라고 합니다.

### Context Switch

수행 중인 프로세스를 변경할 때 레지스터에 프로세스의 정보가 바뀌는 것을 의미합니다.

**예를 들어…**
프로세스 A가 실행중에 프로세스 B로 바뀌었다면 A는 끝난게 아니니까 상태 정보를 저장하고 있어야 하겠죠?

**그럼 어디에 저장하는가?**
A의 PCB에 저장됩니다.
나중에 A가 실행될 때 PCB에서 정보를 가져와 멈췄던 상태 그대로 쓸 수 있게 되는 것이죠.
이렇게 A에서 B로 바뀌는걸 context switch라고 부릅니다.

상태를 저장한다는 걸 **state restore**라고 하고 이는 PCB에 저장됩니다.

즉, Context Switching이란 CPU가 이전의 프로세스 상태를 PCB에 보관하고, 또 다른 프로세스의 정보를 PCB에서 읽어 레지스터에 적재하는 과정을 말합니다.

