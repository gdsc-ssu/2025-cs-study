## 프로세스 스케쥴링

#### 기본 개념

- 1개의 CPU는 1개의 프로세스만을 실행
- 프로세스의 실행은 (CPU 실행 + I/O 대기) 의 주기로 이루어짐.

  - CPU burst : 프로세스 명령어를 수행하는 상태
  - I/O burst : 프로세스가 사용자로 부터 입력 대기, 명렁어 수행 결과 출력 (CPU 대기)
    - 즉 하나의 프로세스에서 I/O burst 가 발생하면 CPU 낭비이니, 이 때 다른 프로세스에서 CPU burst 하면 효율 이 올라가는 것이 핵심임.
  - CPU burst -> I/O busrt -> CPU burst -> I/O burst ->..
  - 마지막 CPU burst는 실행을 종료 요청으로 끝이 남.

- 운영체제는 준비 완료된 큐(ready 상태)에 있는 프로세스 중 하나를 골라 실행

  - 선택은 short term scheduler 에 의해 수행

#### 선점 스케쥴링과 비선점 스케쥴링

- 비선점 스케쥴링 : CPU에서 실행중인 **프로세스가 완료될 때 까지** 다른 프로세스들은 대기 => 즉, 현재 실행 중인 프로세스가 **wait 상태**로 들어가는 순간 다른 프로세스 실행 가능함.

- 선점 스케쥴링 : CPU가 실행 중 => 스케쥴러에 의해 CPU 제어권을 다른 프로세스로 넘김

## Dispatcher

#### 역할

1. context switching

- 현재 실행 중인 프로세스의 상태를 PCB에 저장
- 다음 실행할 프로세스의 상테를 PCB에서 불러옴
- register, PC 등의 값을 복ㅇ원

2. 사용자 모드 전환

- 커널에서 사용자 모드로 전환

3. 프로세스 상태 관리

- 프로세스 큐를 관리

#### Dispatcher가 비선점 스케쥴링에서 작동하는 방식

1. 현재 실행 중인 프로세스가 자발적으로 CPU를 반납할 때 까지 기다림.
2. I/O 요청 | 작업 완료 | wait() 시스템 콜 호출 => 디스패치 개입

#### Dispatcher가 선점 스케쥴링에서 작동하는 방식

1. 더 높은 우선순위의 프로세스가 도착하면 즉시 실행중인 프로세스를 멈추고 CPU를 선점
2. 타임 퀀텀이 만료 | 인터럽트 발생 | 높은 우선순위 프로세스가 ready 상태

#### Dispatcher latency

- dispatcher가 하나의 프로세스를 정지하고 다른 프로세스를 싫행하는데 까지의 소요되는 시간

## Scheduling Criteria

- CPU 이용률
- 처리량
- 대기 시간
- 응답 시간

등이 존재하며, CPU 이용률과 처리량을 최대화하고 대기 시간과 응답 시간을 최소화 하는 것이 바람직

## First-Come, First-Served Scheduling

- 비선점형 스케줄링
- 먼저 요청한 프로세스가 CPU를 먼저 할당 받음
- Queue를 활용하여 쉽게 구현이 가능함.
- 해당 알고리즘에서는 프로세스 도착 순서가 가장 큰 요인
  - 수행이 짧은 프로세스는 긴 프로세스가 끝날때 까지 대기해야하는 현상을 Convoy 효과라고 함

## Shortest-Job-First Scheduling

- CPU 이용이 가능해졌을 때, 가장 작은 CPU 버스트를 가진 프로세스에 할당 (길이가 동일하다면 선입 선출)
- 해당 알고리즘의 어려운 점은 CPU 요청 길이를 파악하는 것 -> 단기 스케쥴링 수준에서는 구현이 불가능한데 왜냐하면 CPU burst 타임을 알 수 있는 방법이 없기 때문

- 비선점형과 선점형 2개가 존재
  앞선 프로세스가 실행하고 있는 동안 새로운 프로세스가 준비 완료 큐에 도착하면 선택을 할 수 있음
  - 선점형 알고리즘은 현재 실행하고 잇는 프로세스를 선점할 것
  - 비선점형 알고리즘은 현재 실행하고 있는 CPU burst를 끝내도록 허용

## Priority Scheduling

- 각 프로세스는 우선순위를 가지고 있으며 가장 높은 우선순위를 가진 프로세스에 CPU 권한을 할당
- 우선순위가 동일하다고 하면 선입선츨로 처리
- SJF 알고리즘도 우선순위를 가지는 알고리즘 중 하나

- 비선점형과 선점형 2개가 존재
  앞선 프로세스가 실행하고 있는 동안 새로운 프로세스가 준비 완료 큐에 도착하면 선택을 할 수 있음

  - 선점형 알고리즘은 우선순위가 현재 실행하고 프로세스보다 높으면 CPU를 점유
  - 비선점형 알고리즘은 준비 완료 큐의 머리 부분에 새로운 프로세스를 넣음

- 우선순위 스케쥴링 알고리즘의 문제점

  1. 무한 봉쇄 (indenfinte blocking)
  2. 기아 상태 (starvation)
     실행 준비는 되어있으나 낮은 우선순위로 인해서 프로세스들이 CPU를 무한히 대기하는 경우에 발생

  이를 해결하기 위한 방법으로 aging 기법을 추가하며 오랫동안 시스템에 대기하는 프로세스의 우선순위를 점진적으로 증가시키기는 기법

## Round-Robin

- 선입 선출과 유사하지만 프로세스를 사이를 옮겨다니기 위해 **선점**이 추가
- 시간 할당량(time-quantum 또는 시간 조각 (time-slice))라는 작은 단위의 시작을 정의 (일단적으로 10 ~ 100ms)
- 과정

  1. 시간 할당량을 정의
  2. 원형 큐에 프로세스들 넣음
  3. 각 프로세스에 시간 할당량 만큼의 CPU를 할당
     만약 CPU burst 길이가 시간 할당량보다 긴 경우에는
  4. 타이머가 끝이 나면 OS가 인터럽트를 발생시킴
  5. Context Switch 수행
  6. 실행하던 프로세스는 준비 완료 큐의 꼬리에 넣음

- 스케쥴링의 성능이 시간 할댱량의 크기에 매우 큰 영향을 받음 => 시간 할댱량이 너무 작으면 Context Switch가 빈번하게 발생해 오버헤드가 매우 크게 발생함.

## Multilevel Queue Scheduling

- 준비 완료 큐를 다수의 별도의 큐로 분류하여 수행하는 방식 (우선순위 큐)
- 각각의 큐는 자신만의 스케쥴링 알고리즘이 존재
  예를 들어 포어그라운드 큐는 RR, 백그라운드 큐는 FCFS

- [높은 우선 순위] 실시간 프로세스 큐 - 시스템 프로세스 큐 - 대화형 프로세스 큐 - 배치 프로세스 큐 [낮은 우선 순위]
  - 실시간 프로세스 큐와 시스템 프로세스 큐에 프로세스가 없어야지만 대화형 프로세스 큐가 실행될 수 있음
  - 대화형 프로세스 큐에 프로세스가 실행 중에 높은 우선 순위 큐에 프로세스가 들어오면 대화형 프로세스 큐의 프로세스들이 선점됨.

## MultiLevel Feedback Queue

- MultiLevel Queue의 단점은 한 큐에서 다른 큐로 이동하지 못한다는 점이다.
- 스케쥴링 오버헤드가 적지만 융통성이 부족.

- 해당 스케쥴링 기법에서는 프로세스가 큐 사이로의 이동을 허용

- CPU 시간을 너무 많이 사용하며 낮은 우선 순위 큐로 이동
- 너무 오래 대기하는 프로세스는 높은 우선순위 큐로 이동 => 기아상태를 예방

## 다중 처리기 스케쥴링

#### 비대칭 다중 처리

- 하나의 처리기가 모든 스케줄링 결과를 입/출력 처리
- 다른 시스템으로의 이동을 취급
- 다른 처러기들은 사용자 코드만을 수행하도록 함

- 하나의 처리기만이 시스템 자료 구조에 접근 -> 자료 공유의 필요성을 배제 (간단해짐)

#### 대칭 다중 처리

- 각각의 처리기가 독자적으로 스케줄링
- 처리기의 스케줄러가 준비 완료 큐를 검사해서 실행할 프로세스를 선택하여 수행

- 주의할 점
  1. 여러개의 처리기가 동공동 자료 구조에 접근하여 갱신한다면 스케쥴러는 신중하게 프로그램이 되어야 함.
  2. 두 처리기가 같은 프로세스를 선택하지 않도록 함.
  3. 프로세스들이 큐에서 사라지지 않도록 보장

#### 처리기 친화성

- SMP 시스템이 같은 처리기에서 프로세스를 실행시켜려고 하는 현상
- 발생 이유 : 처리기로 가장 최근에 접근된 자료가 캐시 메모리에 로드가 되는데, 여러 개의 처리기가 접근을 하면 캐시 메모리를 지우고 채우고 하는 비용이 너무 많이 들기 때문에 발생하는 것

- 종류
  - 약한 친화성 : 동일한 처리기에서 실행시키려는 노력을 하지만 보장이 되지 않아 이주하는 것이 가능
  - 강한 친화성 : 시스템 호출을 통해서 프로세는 다른 처리기로 이주하지 않음을 명시적으로 지정

#### 부하 균등화

- SMP 시스템의 모든 처러기에서 부하가 고르게 배분되도록 시도하는 것

- 방식
  - push 이주
    1. 특정 테스크가 주기적으로 각 처리기의 부하를 검사
    2. 불균형 상태이면 과부하 처리기 -> 쉬고 있더나 덜 바쁜 처리기 로 프로세스 이동(push)
  - pull 이주
    1. 쉬고 있는 처리기가 바쁜 처리기의 프로세스를 가져오는 방식
