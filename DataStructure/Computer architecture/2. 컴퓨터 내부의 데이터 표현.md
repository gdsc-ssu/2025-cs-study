@ -1,128 +0,0 @@
# 2.3 진법의 의미

- 진법 -> 유한한 개수의 심볼로 모든 것을 표현할 수 있다
    -> 0이 반드시 필요하다

- 10진법
'자릿수'와 '나머지'의 개념이 무척이나 중요하다
ex) 432(10) = (4x100+3x10+2X1)
2는 10으로 나눈 나머지, 3은 100으로 나눈 나머지 라고 생각하는 것이 좋다

- 2진법 -> 8진법, 16진법으로의 변환
8진법, 8개의 인자를 가짐(0~7)
16진법, 16개의 인자를 가짐(0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)
2진수 3비트 -> 8진수 1자리 -> LSB부터 3자리씩 묶는다
2진수 4비트 -> 16진수 1자리 -> LSB부터 4자리씩 묶는다

- 정보 표현의 단위

비트(bit): Binary Digit, 0과 1로만 구성된다
컴퓨터 내부에서 정보 저장(표현)의 기본 단위

바이트(byte): 8비트 -> 2의 8승, 256개의 정보 표현 가능
            K(killo) -> 10의 세제곱 근사치인 1024를 사용

            비트의 개수 != 표현할 수 있는 범위
            비트의 개수는 물리적인 저장공간의 크기를 말한다
            8KB = 8*1024 Byte
            표현할 수 있는 범위는 그 수의 비트를 사용하여서 얼마나 많은 다른 값들을 표현할 수 있는지를 말한다
            8KB = 2의 16승 bit -> 2의 65536승 가지수로 표현 가능

워드(word): 여러 바이트를 묶은 시스템 처리 단위이다


# 2.4 진법변환(base conversion)

- 정수 부분의 변환

정수 10진수 -> 2진수로 변환 시 나머지 개념을 이용
ex) 41(10) = 101101(2)
41을 계속 2로 나누면서 가장 큰 값으로 나눈 나머지부터 가장 작은 값으로 나눈 나머지의 방향으로 적어준다

- 소수 부분의 변환

10진수 -> 2진수
소수파트는 곱해서 정수 파트로 올려버린다고 생각하자
정수를 제외한 소수부분에 계속적으로 2를 곱하면서 정수로 자리 올림이 발생하는지 보자

10진수 -> n진수
소수부분에 값 n을 지속적으로 곱해가면 된다

ex) 유한소수 0.2(10) -> 무한순환소수 0.0011(2)
컴퓨터에서는 실수를 정확히 표현할 수 없고, 대부분의 실수는 근사값이다


# 2.5 정수의 표현

컴퓨터에서 숫자 표현 -> 정수(integer numbers)
                -> 실수(real numbers)
정수 2 != 실수 2.0 완전히 다른 2진수 형태로 표시된다
또한 변수(variabes)를 사용하면 변수는 물리적으로 주기억장치(main memory)에 위치하여 3이라는 값을 가지게 된다. 기억장치는 렘의 주소를 추상화 시켜놓은 것이다

정수 -> 부호 없는 정수(unsigned integer): 0, 양의 정수
    -> 부호 있는 정수(signed integer): 0, 양의 정수, 음의 정수

## 부호 없는 정수(unsigned integer): 0, 양의 정수
표현가능 범위: 
0 ~ +(2의 n승 -1) (n비트)
0 ~ +255 (8비트)

- 오버플로우(Overflow)
8비트는 255까지만 표현가능하다
그 다음 자릿수로 넘어가는 오버플로우 발생 시 연산이 틀린다
그렇다고 오버플로우가 나도 프로그램이 멈추진 않는다
컴퓨터는 오버플로우를 발생을 알 수 있음에도,
프로그램 실행 중에 오버플로우 검사를 하면 속도가 느려지므로 오버플로우에 대한 대비를 하지 않는다

255에 1을 더하면 0이 되는 것이다
원처럼 시계 방향으로 돌아서 254 -> 255 -> 0 -> 1 순서가 된다

## 부호 있는 정수(signed integer)
-> 부호와 절댓값 표현(sign and magnitude representation)
-> 보수표현(complement representation)

### 부호와 절댓값(sign and magnitude)
MSB가 0이면 양수, 1이면 음수
ex) +5: 0000 0101(2)
    -5: 1000 0101(2)

표현가능 범위:
-(2의 n-1승 -1) ~ +(2의 n-1승 -1) (n비트)
-127 ~ +127 (8비트)

    - 치명적인 문제점 2개
    1) 0이 2개(+0, -0)
    2) 덧셈이 복잡해진다 -> 속도가 느려짐

### 2의 보수(two's complement)
- 보수란?
절댓값이 같고 부호가 다른 두 수
덧셈의 결과가 0이다

ex) +10(10)의 보수
= 00001010(2)의 보수
= NOT 00001010(2) + 1
= 11110101(2)+ 1
= 11110110(2)
= -10(10)
NOT 연산을 통해 비트반전읠 준다(뺄셈 연산)
그 다음에 +1을 한다
처음에 NOT 연산을 통해 더 큰 수에서 자리 내림을 하기 위해서 1을 뺀 것이기 때문에 나중에 1을 더해준다

- 보수 표현 -> 부호와 절댓값의 문제 해결
1) 부호 없이 음수를 표현할 수 있다
    부호는 없지만, MSB가 0이면 양수이고, MSB가 1이면 음수이다
    부호와 절댓값 표현은 0이 +0, -0으로 두 개 였지만
    2의 보수표현은 0이 한 개라서 으무가 -128까지 한 개 더 존재할 수 있다
2) 덧셈기가 간단해진다

표현가능 범위:
-(2의 n-1승) ~ +(2의 n-1승 -1) (n비트)
-128 ~ +127 (8비트)

- 2의 보수 오버플로우 발생
-1 -> 0 으로 오버플로우 발생
+127 -> -128 으로 오버플로우 발생


# 2.6 실수의 표현